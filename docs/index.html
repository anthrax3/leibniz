<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Leibniz: A Digital Scientific Notation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Leibniz:<span class="mywbr"> &nbsp;</span> A Digital Scientific Notation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.What_s_a_digital_scientific_notation_%29" class="tocviewlink" data-pltdoc="x">What&rsquo;s a digital scientific notation?</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.An_overview_of_.Leibniz%29" class="tocviewlink" data-pltdoc="x">An overview of Leibniz</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.The_anatomy_of_a_.Leibniz_document%29" class="tocviewlink" data-pltdoc="x">The anatomy of a Leibniz document</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Leibniz_reference%29" class="tocviewlink" data-pltdoc="x">Leibniz reference</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Leibniz__.A_.Digital_.Scientific_.Notation%29" class="tocsubseclink" data-pltdoc="x">Leibniz:<span class="mywbr"> &nbsp;</span> A Digital Scientific Notation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.What_s_a_digital_scientific_notation_%29" class="tocsubseclink" data-pltdoc="x">What&rsquo;s a digital scientific notation?</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.An_overview_of_.Leibniz%29" class="tocsubseclink" data-pltdoc="x">An overview of Leibniz</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Terms%29" class="tocsubseclink" data-pltdoc="x">Terms</a></td></tr><tr><td><span class="tocsublinknumber">2.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Chains_of_infix_operators%29" class="tocsubseclink" data-pltdoc="x">Chains of infix operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Variables_vs__symbolic_values%29" class="tocsubseclink" data-pltdoc="x">Variables vs. symbolic values</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Rules%29" class="tocsubseclink" data-pltdoc="x">Rules</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Contexts%29" class="tocsubseclink" data-pltdoc="x">Contexts</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.The_anatomy_of_a_.Leibniz_document%29" class="tocsubseclink" data-pltdoc="x">The anatomy of a Leibniz document</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.A_complete_example%29" class="tocsubseclink" data-pltdoc="x">A complete example</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.More_complex_documents%29" class="tocsubseclink" data-pltdoc="x">More complex documents</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Leibniz_reference%29" class="tocsubseclink" data-pltdoc="x">Leibniz reference</a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._import%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">import</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._inset%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">inset</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._context%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">context</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._sort%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">sort</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._var%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">var</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._op%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">op</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._term%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">term</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._rule%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">rule</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._eval-term%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">eval-<wbr></wbr>term</span></span></a></td></tr><tr><td><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._test%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym"><span class="RktStxLink">test</span></span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">6.8</span></div><h2><a name="(part._.Leibniz__.A_.Digital_.Scientific_.Notation)"></a>Leibniz: A Digital Scientific Notation</h2><p>Leibniz is a digital scientific notation developed primarily for computational physics and chemistry. It is designed to express quantities, equations, and the algorithms that are part of most computational models and methods.</p><p>Leibniz is still in an early stage of development, and therefore likely to change significantly in the future. It is in fact a research project rather than a software development project.  Most of the work in Leibniz development is applying Leibniz to specific scientific questions, identifying its shortcomings, and revising the language to eliminate them.</p><h3>1<tt>&nbsp;</tt><a name="(part._.What_s_a_digital_scientific_notation_)"></a>What&rsquo;s a digital scientific notation?</h3><p>A scientific notation is a convention for using specific arrangements of symbols to describe scientific concepts, models, methods, approximations, etc. Perhaps the best-known and most widely used scientific notations are mathematical formulae and diagrams. Scientific notations have been used for a long time in documents such as textbooks, journal articles, and theses. More recently, we also see them used in software documentation and blog posts. The common point of all these document types is that they mix plain language with more specific scientific notation in a way that suits communication between human scientists.</p><p>A digital scientific notation is a scientific notation that is machine-readable. In other words, it is a <a href="https://en.wikipedia.org/wiki/Formal_language"><span style="font-style: italic">formal language</span></a>, unlike the traditional scientific notations that lack precise computational semantics.</p><p>The two kinds of formal languages used today in computational science are programming languages and data formats. Programming languages are used to construct software tools that perform computations. Data formats are used to store scientific data in a way that facilitates processing by software tools. Neither programming languages nor data formats are suitable for expressing scientific concepts, models, methods, approximations etc. As a result, these crucial aspects of science exist only in informal notations.</p><p>The enormous semantic gap between a journal article outlining a scientific model and a software tool implementing it as part of an optimized algorithm has become a real problem in computational science. Complex scientific models and methods exist only inside software, inaccessible to inspection or modification by most of their users. The translation between informal outlines in journal articles and efficient implementations in software tools is a complex and error-prone process that escapes from the main error-correction mechanism of science: peer review. It has become normal that computational scientists use software without really knowing what it computes, and without any means to verify that the software works correctly.</p><p>Digital scientific notations make it possible to define scientific models and methods in a human-readable document accessible to peer review, and then use testing and formal software verification to ensure that efficient software tools actually compute what these definitions say they should compute. From the point of view of computer science, digital scientific notations are specification languages. They should become an essential part of the human-computer interface in computational science.</p><h3>2<tt>&nbsp;</tt><a name="(part._.An_overview_of_.Leibniz)"></a>An overview of Leibniz</h3><p>The mathematical and computational underpinnings of Leibniz are <a href="https://en.wikipedia.org/wiki/Term_(logic)">term algebras</a>, <a href="https://en.wikipedia.org/wiki/Equational_logic">equational logic</a>, and <a href="https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems">rewriting</a>. In this respect, Leibniz resembles computer algebra systems such as Mathematica, Maple, Maxima, or SymPy. However, Leibniz differs radically from computer algebra systems in being a notation rather than a tool. Leibniz expresses simple term algebras and rewrite rules for human inspection and for reuse, whereas computer algebra systems let their users apply complex term algebras and rewrite rules but keep the term algebras and rewrite rules hidden.</p><p>Leibniz is mainly inspired by the <a href="https://cseweb.ucsd.edu/~goguen/sys/obj.html">OBJ family</a> of algebraic specification language, and in particular by its currently most active incarnation, <a href="http://maude.cs.uiuc.edu/">Maude</a>.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.Terms)"></a>Terms</h4><p><div class="SIntrapara">A Leibniz term is a recursively defined data structure. The simplest terms are
</div><div class="SIntrapara"><ul><li><p>Numbers: 2, -5, 2/3, -1.5</p></li><li><p>Symbolic values: a, b</p></li><li><p>Variables: <span style="font-style: italic">x</span>, <span style="font-style: italic">y</span></p></li></ul></div></p><p><div class="SIntrapara">Complex terms are constructed from simple terms using operators:
</div><div class="SIntrapara"><ul><li><p>Prefix operators: sin(t), &#8730;(2), f(<span style="font-style: italic">x</span>, <span style="font-style: italic">y</span>)</p></li><li><p>Infix operators: a + b, <span style="font-style: italic">x</span> &#247; 2</p></li><li><p>Three special operators: f[t], a<span style="vertical-align: sub; font-size: 80%">i</span>, <span style="font-style: italic">x</span><span style="vertical-align: super; font-size: 80%">2</span></p></li></ul></div></p><p>Each Leibniz term has a <span style="font-style: italic">sort</span> attached to it that characterizes the value represented by the term. For example, the sort of 2 is &#8469;, which is the sort of natural numbers. The sort of -5 is &#8484;nz, the sort of non-zero integers. Sorts can have subsorts, which can be interpreted much like subsets in set theory. For example, &#8484;nz is a subsort of &#8484;, the sort of integers. The sort &#8469; is also a subsort of &#8484;, since all natural numbers are also integers.</p><p><div class="SIntrapara">A term algebra defines which terms are admissible in a specific context and what their sorts are. The definition of a term algebra specifies
</div><div class="SIntrapara"><ul><li><p>a set of sorts</p></li><li><p>a set of subset relations between the sorts</p></li><li><p>a set of symbolic values, each with an assigned sort</p></li><li><p>which numbers are allowed (integer numbers, rational numbers, floating-point numbers</p></li><li><p>a set of variables, each with an assigned sort</p></li><li><p>a set of operators with a specification of sorts for all arguments and the sort of the resulting term</p></li></ul></div></p><p><div class="SIntrapara">As a simple example, a Boolean algebra can be defined as follows:
</div><div class="SIntrapara"><ul><li><p>the single sort &rsquo;boolean&rsquo;</p></li><li><p>the symbolic values &rsquo;true:boolean&rsquo; and &rsquo;false:boolean&rsquo;</p></li><li><p>the prefix operator &rsquo;not(boolean) : boolean&rsquo;</p></li><li><p>the infix operators &rsquo;boolean &#8743; boolean : boolean&rsquo; and &rsquo;boolean &#8744; boolean : boolean&rsquo;</p></li></ul></div><div class="SIntrapara">In this term algebra, &rsquo;true &#8743; not(false)&rsquo; and &rsquo;not(true &#8744; false &#8743; true)&rsquo; are valid terms, both of sort &rsquo;boolean&rsquo;, whereas &rsquo;true &#8743; 2&rsquo; is not (no numbers are allowed), nor is &rsquo;true + false&rsquo; (the operator + was not defined for boolean values).</div></p><p><div class="SIntrapara">Note that there is nothing special about + or &#8744; in Leibniz. Prefix and infix operators can be almost arbitrary symbols, and you can make up any number of them. Our Boolean algebra could just as well be defined as
</div><div class="SIntrapara"><ul><li><p>the single sort &rsquo;B&rsquo;</p></li><li><p>the symbolic values &rsquo;T:B&rsquo; and &rsquo;F:B&rsquo;</p></li><li><p>the prefix operator &rsquo;!(B) : B&rsquo;</p></li><li><p>the infix operators &rsquo;B AND B : B&rsquo; and &rsquo;B OR B : B&rsquo;</p></li></ul></div><div class="SIntrapara">with valid terms looking like &rsquo;T AND !(F)&rsquo;. The choice of names is entirely up to the authors of a scientific text, although it certainly makes sense to respect long-standing conventions.</div></p><h5>2.1.1<tt>&nbsp;</tt><a name="(part._.Chains_of_infix_operators)"></a>Chains of infix operators</h5><p><div class="SIntrapara">This enormous freedom in defining operators also means that it is not practical to define precedence rules such as "multiplication before addition" in traditional mathematics. Leibniz has no precedence rules whatsoever. There is only one rule for interpreting complex terms with multiple infix operators:
</div><div class="SIntrapara"><blockquote><p>The right-hand argument of every infix operator is everything to its right.</p></blockquote></div><div class="SIntrapara">This means that &rsquo;2 &#215; 3 + 4&rsquo; is read as &rsquo;2 &#215; (3 + 4)&rsquo;, and that &rsquo;not(true &#8744; false &#8743; true)&rsquo; is the same as &rsquo;not(true &#8744; (false &#8743; true))&rsquo;.</div></p><h5>2.1.2<tt>&nbsp;</tt><a name="(part._.Variables_vs__symbolic_values)"></a>Variables vs. symbolic values</h5><p><div class="SIntrapara">Unlike traditional mathematical notation, Leibniz requires a careful distinction between variables (typeset in italics) and symbolic values. A symbolic value stands for a specific number or quantity, even though its numerical value may not be known. A variable stands for <span style="font-style: italic">an arbitrary value</span> of a given sort. Variables are mainly used in equations. As a simple example, the equation
</div><div class="SIntrapara"><blockquote><p>f(t) = g(t)</p></blockquote></div><div class="SIntrapara">means that for a specific value t, f(t) is equal to g(t). In contrast, the equation
</div><div class="SIntrapara"><blockquote><p>f(<span style="font-style: italic">t</span>) = g(<span style="font-style: italic">t</span>)</p></blockquote></div><div class="SIntrapara">means that the functions f and g are equal for all possible values of <span style="font-style: italic">t</span>.</div></p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Rules)"></a>Rules</h4><p><div class="SIntrapara">A Leibniz rule takes the form &rsquo;term1 &#8658; term2&rsquo;. It affirms two facts:
</div><div class="SIntrapara"><ul><li><p>term1 and term2 are equal</p></li><li><p>term2 is considered simpler or preferable for some other reason</p></li></ul></div><div class="SIntrapara">When you ask Leibniz to <span style="font-style: italic">reduce</span> a term, it applies all rules that are applicable,
until no further rule application is possible. Applying a rule means searching for
term1 anywhere inside the term to be reduced, and replacing it by term2.</div></p><p>As an example, given the symbolic value &rsquo;a:&#8469;&rsquo; and the rule &rsquo;a &#8658; 2&rsquo;, Leibniz will
reduce the term &rsquo;5 &#215; a&rsquo; to &rsquo;5 &#215; 2&rsquo; and then to &rsquo;10&rsquo; by applying a built-in rule
for multiplication of numbers.</p><p><div class="SIntrapara">Rules become really powerful when they contain variables. A term containing variables
is called a pattern, and rules with patterns can be applied to any term that matches
the pattern. Suppose we define a variable &rsquo;<span style="font-style: italic">x</span>:&#8477;&rsquo; and a rule &rsquo;<span style="font-style: italic">x</span><span style="vertical-align: super; font-size: 80%">2</span> &#8658; <span style="font-style: italic">x</span> &#215; <span style="font-style: italic">x</span>&rsquo;, then this rule can be applied
to various terms:
</div><div class="SIntrapara"><ul><li><p>&rsquo;a<span style="vertical-align: super; font-size: 80%">2</span>&rsquo; will be reduced to &rsquo;a &#215; a&rsquo;</p></li><li><p>&rsquo;3 &#215; (2 &#215; a)<span style="vertical-align: super; font-size: 80%">2</span>&rsquo; will be reduced to &rsquo;3 &#215; (2 &#215; a) &#215; 2 &#215; a&rsquo;</p></li><li><p>&rsquo;(a<span style="vertical-align: super; font-size: 80%">2</span>)<span style="vertical-align: super; font-size: 80%">2</span>&rsquo; will be reduced to &rsquo;a &#215; a &#215; a &#215; a&rsquo; (by applying the rule twice)</p></li></ul></div></p><p><div class="SIntrapara">Rules are used for serveral purposes in Leibniz:
</div><div class="SIntrapara"><ul><li><p>to express algorithms</p></li><li><p>to simplify terms</p></li><li><p>to replace symbolic values by concrete values (e.g. numbers)</p></li></ul></div></p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Contexts)"></a>Contexts</h4><p>The basic unit of Leibniz code is called a <span style="font-style: italic">context</span>, because it defines
the semantic context for all computations. A context defines a term algebra,
e.g. sorts, subsort relations, and definitions for operators and symbolic values.
Contexts can also contain any number of rules. Future versions of Leibniz will
add relations between variables and values defined in the context.</p><h3>3<tt>&nbsp;</tt><a name="(part._.The_anatomy_of_a_.Leibniz_document)"></a>The anatomy of a Leibniz document</h3><p><div class="SIntrapara">Being a scientific notation, Leibniz code is embedded into plain text written by and for human scientists. A Leibniz document is written using a markup language that is an extension of the Scribble language used for Racket documentation. The Leibniz document processor reads this markup language and generates from it
</div><div class="SIntrapara"><ul><li><p>A human-readable version in HTML format</p></li><li><p>A machine-readable version in XML format</p></li></ul></div></p><p>The Scribble lanuguage is documented in <a href="http://download.racket-lang.org/releases/6.8/doc/scribble/index.html" data-pltdoc="x">Scribble: The Racket Documentation Tool</a>. For scientists familiar with LaTeX, it should look familiar, although it differs in many important details.  Scribble markup is used to define the overall document structure (title, sections, subsections, cross references, ...) and layout (text styles such as bold or italic, lists, tables, etc.). Leibniz adds a few markup commands, which are explained below.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.A_complete_example)"></a>A complete example</h4><p>The following code is a minimal complete Leibniz document. Click <a href="http://khinsen.net/leibniz-examples/examples/euclid_gcd.html">here</a> to see how it is rendered to HTML.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="http://download.racket-lang.org/releases/6.8/doc/guide/Module_Syntax.html#%28part._hash-lang%29" class="RktModLink" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><font class="badlink"><span class="RktModLink"><span class="RktSym">leibniz</span></span></font><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._title%29%29" class="RktValLink" data-pltdoc="x">title</a></span><span class="RktPn">{</span><span class="RktMeta">The</span><span class="hspace">&nbsp;</span><span class="RktMeta">greatest</span><span class="hspace">&nbsp;</span><span class="RktMeta">common</span><span class="hspace">&nbsp;</span><span class="RktMeta">divisor</span><span class="hspace">&nbsp;</span><span class="RktMeta">of</span><span class="hspace">&nbsp;</span><span class="RktMeta">two</span><span class="hspace">&nbsp;</span><span class="RktMeta">natural</span><span class="hspace">&nbsp;</span><span class="RktMeta">numbers</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._author%29%29" class="RktValLink" data-pltdoc="x">author</a></span><span class="RktPn">{</span><span class="RktMeta">Euclid</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._context%29%29" class="RktStxLink" data-pltdoc="x">context</a></span><span class="RktPn">[</span><span class="RktVal">"gcd"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">#:use</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"builtins/integers"</span><span class="RktPn">]</span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">The</span><span class="hspace">&nbsp;</span><span class="RktMeta">greatest</span><span class="hspace">&nbsp;</span><span class="RktMeta">common</span><span class="hspace">&nbsp;</span><span class="RktMeta">divisor</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._op%29%29" class="RktStxLink" data-pltdoc="x">op</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(a:&#8469;,</span><span class="hspace">&nbsp;</span><span class="RktMeta">b:&#8469;)</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8469;</span><span class="RktPn">}</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">of</span><span class="hspace">&nbsp;</span><span class="RktMeta">two</span><span class="hspace">&nbsp;</span><span class="RktMeta">natural</span><span class="hspace">&nbsp;</span><span class="RktMeta">numbers</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._var%29%29" class="RktStxLink" data-pltdoc="x">var</a></span><span class="RktPn">{</span><span class="RktMeta">a:&#8469;</span><span class="RktPn">}</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">and</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._var%29%29" class="RktStxLink" data-pltdoc="x">var</a></span><span class="RktPn">{</span><span class="RktMeta">b:&#8469;</span><span class="RktPn">}</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">can</span><span class="hspace">&nbsp;</span><span class="RktMeta">be</span><span class="hspace">&nbsp;</span><span class="RktMeta">obtained</span><span class="hspace">&nbsp;</span><span class="RktMeta">by</span><span class="hspace">&nbsp;</span><span class="RktMeta">applying</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">following</span><span class="hspace">&nbsp;</span><span class="RktMeta">rules:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._itemlist%29%29" class="RktValLink" data-pltdoc="x">itemlist</a></span><span class="RktPn">[</span><span class="RktPn">#:style</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">'</a></span><span class="RktSym">ordered</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._item%29%29" class="RktValLink" data-pltdoc="x">item</a></span><span class="RktPn">{</span><span class="RktMeta">If</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">two</span><span class="hspace">&nbsp;</span><span class="RktMeta">numbers</span><span class="hspace">&nbsp;</span><span class="RktMeta">are</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal,</span><span class="hspace">&nbsp;</span><span class="RktMeta">their</span><span class="hspace">&nbsp;</span><span class="RktMeta">GCD</span><span class="hspace">&nbsp;</span><span class="RktMeta">is</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">them</span><span class="hspace">&nbsp;</span><span class="RktMeta">as</span><span class="hspace">&nbsp;</span><span class="RktMeta">well:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._linebreak%29%29" class="RktValLink" data-pltdoc="x">linebreak</a></span><span class="RktPn">[</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._rule%29%29" class="RktStxLink" data-pltdoc="x">rule</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(a,</span><span class="hspace">&nbsp;</span><span class="RktMeta">a)</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="RktPn">}</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._item%29%29" class="RktValLink" data-pltdoc="x">item</a></span><span class="RktPn">{</span><span class="RktMeta">If</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">b,</span><span class="hspace">&nbsp;</span><span class="RktMeta">replace</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">by</span><span class="hspace">&nbsp;</span><span class="RktMeta">a-b:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._linebreak%29%29" class="RktValLink" data-pltdoc="x">linebreak</a></span><span class="RktPn">[</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._rule%29%29" class="RktStxLink" data-pltdoc="x">rule</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(a,</span><span class="hspace">&nbsp;</span><span class="RktMeta">b)</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktMeta">gcd(a</span><span class="hspace">&nbsp;</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">b,</span><span class="hspace">&nbsp;</span><span class="RktMeta">b)</span><span class="hspace">&nbsp;</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="RktPn">}</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._item%29%29" class="RktValLink" data-pltdoc="x">item</a></span><span class="RktPn">{</span><span class="RktMeta">Otherwise</span><span class="hspace">&nbsp;</span><span class="RktMeta">we</span><span class="hspace">&nbsp;</span><span class="RktMeta">have</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">and</span><span class="hspace">&nbsp;</span><span class="RktMeta">replace</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">by</span><span class="hspace">&nbsp;</span><span class="RktMeta">b-a:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._linebreak%29%29" class="RktValLink" data-pltdoc="x">linebreak</a></span><span class="RktPn">[</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._rule%29%29" class="RktStxLink" data-pltdoc="x">rule</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(a,</span><span class="hspace">&nbsp;</span><span class="RktMeta">b)</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktMeta">gcd(a,</span><span class="hspace">&nbsp;</span><span class="RktMeta">b</span><span class="hspace">&nbsp;</span><span class="RktMeta">-</span><span class="hspace">&nbsp;</span><span class="RktMeta">a)</span><span class="RktPn">}</span><span class="RktPn">}</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">Here</span><span class="hspace">&nbsp;</span><span class="RktMeta">are</span><span class="hspace">&nbsp;</span><span class="RktMeta">some</span><span class="hspace">&nbsp;</span><span class="RktMeta">application</span><span class="hspace">&nbsp;</span><span class="RktMeta">examples:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._itemlist%29%29" class="RktValLink" data-pltdoc="x">itemlist</a></span><span class="RktPn">[</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._item%29%29" class="RktValLink" data-pltdoc="x">item</a></span><span class="RktPn">{</span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._eval-term%29%29" class="RktStxLink" data-pltdoc="x">eval-term</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(2,</span><span class="hspace">&nbsp;</span><span class="RktMeta">3)</span><span class="RktPn">}</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._item%29%29" class="RktValLink" data-pltdoc="x">item</a></span><span class="RktPn">{</span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._eval-term%29%29" class="RktStxLink" data-pltdoc="x">eval-term</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(3,</span><span class="hspace">&nbsp;</span><span class="RktMeta">2)</span><span class="RktPn">}</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/scribble/base.html#%28def._%28%28lib._scribble%2Fbase..rkt%29._item%29%29" class="RktValLink" data-pltdoc="x">item</a></span><span class="RktPn">{</span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._eval-term%29%29" class="RktStxLink" data-pltdoc="x">eval-term</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(42,</span><span class="hspace">&nbsp;</span><span class="RktMeta">7)</span><span class="RktPn">}</span><span class="RktPn">}</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">Most of the commands starting with @ come from Scribble and deal with text formatting.
The four Leibniz commands used in this example are
</div><div class="SIntrapara"><ul><li><p><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._context%29%29" class="RktStxLink" data-pltdoc="x">context</a></span><span class="RktPn">{</span><span class="RktPn">}</span><span class="RktMeta"></span> defines a context. In the square brackets, it requires the name of the new context ("gcd" in the example) and accepts a list of already existing contexts that are used by the one being defined ("builtins/integers" in the example). Using a context is equivalent to inserting a copy of that context&rsquo;s definition.</p><p>In the curly braces, you can use arbitrary Scribble text and also most Leibniz commands. In fact, most Leibniz commands are allowed only inside a context definition.</p></li><li><p><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._var%29%29" class="RktStxLink" data-pltdoc="x">var</a></span><span class="RktPn">{</span><span class="RktPn">}</span><span class="RktMeta"></span> declares a variable giving its name and the sort that its values must have. In the example, both variables are of sort &#8469;, which is the sort of natural numbers defined in the context "builtins/integers".</p></li><li><p><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._op%29%29" class="RktStxLink" data-pltdoc="x">op</a></span><span class="RktPn">{</span><span class="RktPn">}</span><span class="RktMeta"></span> declares an operator giving its name, its argument declarations, and its sort. In the example, "gcd" is a binary operator that requires two arguments of sort &#8469; and is itself of sort &#8469;. The argument declarations look like varible declarations and in fact that&rsquo;s what they are. Alternatively, a plain sort name is sufficient, so we could have written simply <span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._op%29%29" class="RktStxLink" data-pltdoc="x">op</a></span><span class="RktPn">{</span><span class="RktMeta">gcd(&#8469;,</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8469;)</span><span class="hspace">&nbsp;</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta">&#8469;</span><span class="RktPn">}</span><span class="RktMeta"></span>. The advantage of adding variable names is that one can refer to the arguments by name in the surrounding text.</p></li><li><p><span class="RktMeta"></span><span class="RktPn">@</span><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._rule%29%29" class="RktStxLink" data-pltdoc="x">rule</a></span><span class="RktPn">{</span><span class="RktPn">}</span><span class="RktMeta"></span> defines a rewrite rule of the form "pattern &#8658; replacement", optionally followed by a condition. The three rules in this example correspond to the three cases a = b, a &gt; b, and a &lt; b.</p></li></ul></div></p><h4>3.2<tt>&nbsp;</tt><a name="(part._.More_complex_documents)"></a>More complex documents</h4><p>A Leibniz document can define any number of contexts, and each context can <span class="RktMeta"></span><span class="RktMeta">#:use</span><span class="RktMeta"></span> contexts defined earlier in the document. A context can also be transformed before being used, which is demonstrated in some of the examples. However, the transformation mechanism is not stable yet, and will be documented in a later version of this manual.</p><p>A Leibniz document can also <span class="RktMeta"></span><span class="RktMeta">#:use</span><span class="RktMeta"></span> contexts from other Leibniz documents. With the exception of the "builtins" document that contains the contexts "truth", "integers", "rational-numbers", "real-numbers", and "IEEE-floating-point", other documents must be <span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._import%29%29" class="RktStxLink" data-pltdoc="x">import</a></span>ed before their contexts can be used.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Leibniz_reference)"></a><a name="(mod-path._leibniz/lang)"></a>Leibniz reference</h3><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._leibniz%2Flang%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">leibniz/lang</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <span class="stt">leibniz</span></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._import))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._import%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">import</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">document-name</span><span class="hspace">&nbsp;</span><span class="RktVar">xml-filename</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><blockquote class="SubFlow"><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">document-name</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">xml-filename</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/Manipulating_Paths.html#%28def._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._path-string~3f%29%29" class="RktValLink" data-pltdoc="x">path-string?</a></span></td></tr></table></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Import another Leibniz document in XML format from <span class="RktVar">xml-filename</span>,
and define <span class="RktVar">document-name</span> as its local name. A context name
of the form <span class="RktVal">"foo/bar"</span> can then be used to refer to the context
defined as <span class="RktVal">"bar"</span> in a document imported with local name <span class="RktVal">"foo"</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._inset))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._inset%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">inset</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">item</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Render <span class="RktVar">item</span>s in an inset block, respecting line breaks in the input.
This is merely a shorthand for a Scribble pattern that is frequently useful
when writing Leibniz code.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><table cellspacing="0" cellpadding="0" class="RktBlk RForeground"><tr><td><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._context))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._context%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">context</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">name</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">#:use</span><span class="hspace">&nbsp;</span><span class="RktVar">other-context</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVar">item</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><blockquote class="SubFlow"><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">name</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">other-context</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Defines a new Leibniz context <span class="RktVar">name</span> that uses
<span class="RktVar">other-context</span>s, which are either defined earlier in the
document or in an <span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._import%29%29" class="RktStxLink" data-pltdoc="x">import</a></span>ed document.</div></p><p>The <span class="RktVar">item</span>s can be anything allowed in a Scribble document,
plus the Leibniz-specific items defined below.</p><p>All the following commands can only be used inside a <span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._context%29%29" class="RktStxLink" data-pltdoc="x">context</a></span>.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._sort))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._sort%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">sort</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">sort-declaration</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">sort-declaration</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Adds <span class="RktVar">sort-declaration</span> to the context and typesets it on a blue background.</div></p><p><div class="SIntrapara">A sort declaration can take two forms:
</div><div class="SIntrapara"><ul><li><p>"sort" declares that "sort" is a valid sort name</p></li><li><p>"sort1 &#8838; sort2" declares that "sort1" is a subsort of "sort2"</p></li></ul></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._var))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._var%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">var</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">var-declaration</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">var-declaration</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Adds <span class="RktVar">var-declaration</span> to the context and typesets it on a blue background.</div></p><p>A variable declaration takes the form "var-name:sort", where "var-name" is the name of the variable and "sort" is the name of a sort defined in the context.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._op))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._op%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">op</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">op-declaration</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">op-declaration</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Adds the operator defined by <span class="RktVar">op-declaration</span> to the context and typesets
it on a blue blackground.</div></p><p><div class="SIntrapara">An operator declaration can take several forms:
</div><div class="SIntrapara"><ul><li><p>"op-name : sort" declares "op-name" to be a symbolic value (nullary operator) of sort "sort"</p></li><li><p>"op-name(arg1, arg2, ...argN) : sort" declares "op-name" to be an n-ary operator of sort "sort". </p></li><li><p>"arg1 op-name arg2 : sort" declares an infix operator "op-name" of sort "sort"</p></li><li><p>"arg1[arg2] : sort" declares a special operator of sort "sort"</p></li><li><p>"arg1^{arg2} : sort" declares a special operator of sort "sort" that is typeset as arg1<span style="vertical-align: super; font-size: 80%">arg2</span></p></li><li><p>"arg1_{arg2} : sort" declares a special operator of sort "sort" that is typeset as arg1<span style="vertical-align: sub; font-size: 80%">arg2</span></p></li></ul></div></p><p><div class="SIntrapara">In the above operator declarations, the argument declarations "arg1" to "argN" are one of
</div><div class="SIntrapara"><ul><li><p>the name of a sort defined in the context</p></li><li><p>a variable declaration of the type "var-name:sort"</p></li></ul></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._term))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._term%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">term</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term-expr</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">term-expr</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Verify the validity of <span class="RktVar">term-expr</span> in the context and typeset it on a blue background. The context is not modified in any way.</div></p><p><div class="SIntrapara">The syntax for <span class="RktVar">term-expr</span> is
</div><div class="SIntrapara"><ul><li><p>a number (integer, rational, floating-point).</p></li><li><p>"(term)", where "term" is any valid term.</p></li><li><p>"name", where "name" is a variable name or the name of a nullary operator.</p></li><li><p>"op-name(arg1, arg2, ... argN)", where "op-name" is the name of an N-ary operator and "arg1", ..., "argN" are terms.</p></li><li><p>"arg1 op-name arg2", where "op-name" is the name of an infix operator and "arg1"/"arg2" are terms.</p></li><li><p>"arg1[arg2]", where "arg1" and "arg2" are terms.</p></li><li><p>"arg1^{arg2}", where "arg1" and "arg2" are terms.</p></li><li><p>"arg1_{arg2}", where "arg1" and "arg2" are terms.</p></li></ul></div></p><p>An expression with multiple infix operators is grouped from right to left:
"arg1 infix-op-1 arg2 infix-op-2 arg3" is equivalent to "arg1 infix-op-1 (arg2 infix-op-2 arg3)".</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._rule))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._rule%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">rule</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">rule-expr</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">rule-expr</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Add a rewrite rule to the context, and typeset it on a blue background.</div></p><p><div class="SIntrapara">The syntax for <span class="RktVar">rule-expr</span> is "term1 &#8658; term2" followed by any number of
</div><div class="SIntrapara"><ul><li><p>conditions of the form "if term", where "term" is a term of sort "boolean".</p></li><li><p>local variable declarations of the form "&#8704; var-name:sort"</p></li></ul></div><div class="SIntrapara">All terms in <span class="RktVar">rule-expr</span> can contain the variables defined in the context and the variables declared locally for the rule.</div></p><p>Note that rules are the only items in a context whose order matters, because during rewriting rules are tried in the order they were written.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._eval-term))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._eval-term%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">eval-term</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term-expr</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">term-expr</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Verify the validity of <span class="RktVar">term-expr</span> in the context and typeset it on a blue background. Evaluate the term by applying the rules defined in the context and typeset the resulting term on a green background after a "&#8658;" inserted as a separator.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._leibniz/lang..rkt)._test))"></a><span title="Provided from: leibniz/lang | Package: leibniz"><span class="RktSym"><a href="#%28form._%28%28lib._leibniz%2Flang..rkt%29._test%29%29" class="RktStxDef RktStxLink" data-pltdoc="x">test</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">test-expr</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="argcontract"><tr><td><span class="hspace">&nbsp;&nbsp;</span></td><td><span class="RktVar">test-expr</span></td><td><span class="hspace">&nbsp;</span></td><td>:</td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym"><a href="http://download.racket-lang.org/releases/6.8/doc/reference/strings.html#%28def._%28%28quote._~23~25kernel%29._string~3f%29%29" class="RktValLink" data-pltdoc="x">string?</a></span></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Evaluate the first term in <span class="RktVar">test-expr</span> and compare it to the second term. Typeset <span class="RktVar">test-expr</span> on a blue background. If the two are equal, add a green checkmark, else a red cross.</div></p><p>The syntax for <span class="RktVar">test-expr</span> is "term1 &#8658; term2". Neither term is allowed to contain variables.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>